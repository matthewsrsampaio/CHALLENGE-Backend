server:
  port: ${PORT:8081}

spring:
  main:
    #allow-circular-references: true # permite referencias circulares
    allow-bean-definition-overriding: true # permite usar criar um bean de um serviço interno do próprio spring

  application:
    name: subscription


  #Preciso configurar o resto
  datasource:
    driver-class-name: org.postgresql.Driver
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5433}/${DB_NAME:subscription-db}
    username: ${DB_USE:admin}
    password: ${DB_PASSWORD:123456}
    initialize: true
    maxActive: 3

  sql:
    init:
      mode:
      continue-on-error: true
      platform: postgresql

  jpa:
    hibernate:
      ddl-auto: create-drop #desabilitar o ddl-auto em caso de ambiente de produção. Pq ele sempre dropa a tabela quando a aplicação é parada.
      format_sql: true
    show-sql: true
    properties:
      hibernate:
      dialect: org.hibernate.dialect.PostgreSQLDialect #Rodando o mais atual

  #    Setando o serviço do rabbitMQ
  # Cloud AMQP: amqps://pfxkfxdx:qbyROSoIXWlXcFEEn5J00LH-_5G020RP@beaver.rmq.cloudamqp.com/pfxkfxdx
  rabbitmq:
    host: ${RABBIT_MQ_HOST:localhost} #valor default: localhost
    port: ${RABBIT_MQ_PORT:5672}  #valor default: 5672
    username: ${RABBIT_MQ_USER:guest} #valor default: guest
    password: ${RABBIT_MQ_PASSWORD:guest} #valor default: guest
    #virtual-host: ${RABBIT_MQ_VHOST:pfxkfxdx} #O valor default é vazio Ex: ${RABBIT_MQ_VHOST:}

app-config:
  rabbit:
    exchange:
      subscription: subscription.topic
      #product: product.topic

    routingKey:
      subscription-update: subscription-update.routingKey
      #product-stock: product-stock-update.routingKey
      #sales-confirmation: sales-confirmation.routingKey

    queue:
      subscription-update: subscription-update.queue
      #product-stock: product-stock-update.queue
      #sales-confirmation: sales-confirmation.queue
